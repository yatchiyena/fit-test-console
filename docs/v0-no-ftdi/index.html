<!doctype html>
<html lang="en">
<head>
    <link rel="manifest" href="manifest.json"/>
    <style>
        table {
            border-collapse: collapse;
        }

        table th {
            padding: 0.5rem;
            border-bottom: 5px solid black;
            border-left: 2px solid black;
        }

        th {
            position: sticky;
            top: 0;
            background-color: white;
            border-bottom: 5px solid black;
        }

        table td {
            padding: 0.5rem;
            border: 2px solid black;
        }

        table th:last-child {
            border-right: 2px solid black;
        }

        div.editable-table-cell {
            display: inline-block;
            outline: none;
        }

        td.results {
            text-align: end;
        }

        td.pass {
            background-color: green;
            color: white;
        }

        td.fail {
            background-color: darkred;
            color: white;
        }

        td.aborted {
            background-color: gray;
            text-align: center;
        }
    </style>
</head>
<body>
<section>
    <fieldset style="max-width:fit-content; float:left">
        <legend>Baud Rate</legend>
        <select id="baud-rate-selector">
            <option value="300">300</option>
            <option value="600">300</option>
            <option value="1200" selected="selected">1200 (default)</option>
            <option value="2400">2400</option>
            <option value="9600">9600</option>
        </select>
    </fieldset>
    <fieldset style="max-width:fit-content; float:left">
        <legend>Data Source</legend>
        <select id="data-source-selector">
            <option value="ftdi">FTDI</option>
            <option value="web-serial" selected="selected">WebSerial</option>
            <option value="simulator">Simulator</option>
            <option value="database">Database</option>
            <option value="results-db">Prev Results</option>
        </select>
        <input type="button" value="Connect" id="connect-button" style="font-size:2cqw; width:10vw; height:3vw">
    </fieldset>
    <fieldset style="max-width:fit-content; float:left">
        <legend>Options</legend>
        <div style="display:inline-block">
            <input type="checkbox" id="enable-speech-checkbox">
            <label for="enable-speech-checkbox">Enable Speech</label>
        </div>
        <div style="display:inline-block">
            <input type="checkbox" id="enable-verbose-speech-checkbox">
            <label for="enable-verbose-speech-checkbox">Verbose</label>
        </div>
        <div style="display:inline-block">
            <input type="checkbox" id="speak-concentration-checkbox">
            <label for="speak-concentration-checkbox">Say particle count</label>
        </div>
    </fieldset>
    <fieldset style="max-width:fit-content; float:left">
        <legend>Download Data</legend>
        <select id="download-file-format-selector">
            <option value="raw">Raw</option>
            <option value="csv" selected="selected">CSV</option>
            <option value="json">JSON</option>
        </select>
        <input type="button" value="Download!" id="download-button">
    </fieldset>
</section>
<br/>
<fieldset id="portacount-controls-fieldset" style="display:inline-block">
    <legend>PortaCount control</legend>
</fieldset>
<br/>
<section>
    <fieldset>
        <legend>Instructions</legend>
        <div id="instructions" style="width:fit-content;min-height:3rem; height:fit-content; font-size:xxx-large; overflow:auto; resize: both"></div>
    </fieldset>
</section>
<section id="collected-data">
    <fieldset>
        <legend>Test Info</legend>
        <div id="data-table-div" style="height: 10rem;min-height: 40vh; overflow: auto; resize: both">
            <table id="fit-test-data-table" style="font-size:2vw">
                <thead>
                <tr id="test-data-header-row">
                    <th>ID</th>
                    <th style="min-width:10vw">Time</th>
                    <th>Participant</th>
                    <th>Mask</th>
                    <th>Notes</th>
                </tr>
                </thead>
                <tbody id="test-data-body">

                </tbody>
            </table>
        </div>
    </fieldset>
</section>
<fieldset style="float:left">
    <legend>Raw Data</legend>
    <textarea id="raw-data" readonly style="width:40vw;height:200px" tabindex="1000"></textarea>
</fieldset>
<fieldset style="float:left">
    <legend>Processed Data</legend>
    <textarea id="interpreted-data" readonly style="width:300px;height:200px" tabindex="1001"></textarea>
</fieldset>
<fieldset style="float:left">
    <legend>Log</legend>
    <textarea id="log-text-area" readonly style="width:90vw;height:200px" tabindex="1002"></textarea>
</fieldset>

<script type="module" id="everything-in-one-module">
    /*
    Collect data from PortaCount 8020a
     */

    // data output patterns
    const PORTACOUNT_VERSION_PATTERN = /^PORTACOUNT\s+PLUS\S+PROM\S+(?<version>.+)/i; // PORTACOUNT PLUS PROM V1.7
    const COPYRIGHT_PATTERN = /^COPYRIGHT.+/i; // COPYRIGHT(c)1992 TSI INC
    const LICENSE_PATTERN = /^ALL\s+RIGHTS\s+RESERVED/i; // ALL RIGHTS RESERVED
    const SERIAL_NUMBER_PATTERN = /^Serial\s+Number\s+(?<serialNumber>\d+)/i; // Serial Number 17754
    const PASS_LEVEL_PATTERN = /^FF\s+pass\s+level\s+(?<passLevel>\d+)/i; // FF pass level = 100
    const NUM_EXERCISES_PATTERN = /^No\.\s+of\s+exers\s*=\s*(?<numExercises>\d+)/i; // No. of exers  = 4
    const AMBIENT_PURGE_PATTERN = /^Ambt\s+purge\s*=\s*(?<ambientPurgeTime>\d+)/i; // Ambt purge   = 4 sec.
    const AMBIENT_SAMPLE_PATTERN = /^Ambt\s+sample\s*=\s*(?<ambientSampleTime>\d+)/i; // Ambt sample  = 5 sec.
    const MASK_PURGE_PATTERN = /^Mask\s+purge\s*=\s*(?<maskPurgeTime>\d+)/i; // Mask purge  = 11 sec.
    const MASK_SAMPLE_PATTERN = /^Mask\s+sample\s+(?<exerciseNumber>\d+)\s*=\s*(?<maskSampleTime>\d+)/i; // Mask sample 1 = 40 sec.
    const DIP_SWITCH_PATTERN = /^DIP\s+switch\s+=\s+(?<dipSwitchBits>\d+)/i; // DIP switch  = 10111111
    const COUNT_READING_PATTERN = /^Conc\.\s+(?<concentration>[\d\.]+)/i; // Conc.      0.00 #/cc
    const NEW_TEST_PATTERN = /^NEW\s+TEST\s+PASS\s*=\s*(?<passLevel>\d+)/i; // NEW TEST PASS =  100
    const AMBIENT_READING_PATTERN = /^Ambient\s+(?<concentration>[\d\.]+)/i; // Ambient   2290 #/cc
    const MASK_READING_PATTERN = /^Mask\s+(?<concentration>[\d+\.]+)/i; // Mask    5.62 #/cc
    const FIT_FACTOR_PATTERN = /^FF\s+(?<exerciseNumber>\d+)\s+(?<fitFactor>[\d\.]+)\s+(?<result>.+)/; // FF  1    352 PASS
    const TEST_TERMINATED_PATTERN = /^Test\s+Terminated/i; // Test Terminated
    const OVERALL_FIT_FACTOR_PATTERN = /^Overall\s+FF\s+(?<fitFactor>[\d\.]+)\s+(?<result>.+)/i; // Overall FF    89 FAIL
    const LOW_PARTICLE_COUNT_PATTERN = /^(?<concentration>\d+)\/cc\s+Low\s+Particle\s+Count/i; // 970/cc Low Particle Count

    // external control patterns
    const PARTICLE_COUNT_PATTERN = /^\s*(?<concentration>\d+\.\d+)\s*/; // 006408.45


    export class DataCollector {
        static nextTabIndex = 100;
        resultsDatabase;
        beginExerciseTimoutId = null;
        logTextArea;
        dataTextArea;
        instructionsTextArea;
        currentTestData;
        testDataHeaderRow;
        testDataBody = null;
        testDataCurrentRow = null;
        tableElement;
        headerComplete = false;
        exerciseCount = 0; // we don't know up front how many exercises there are per test

        constructor(logTextArea, dataTextArea, instructionsTextArea, resultsDatabase) {
            this.logTextArea = logTextArea;
            this.dataTextArea = dataTextArea;
            this.instructionsTextArea = instructionsTextArea;
            this.testDataHeaderRow = document.getElementById("test-data-header-row");
            this.testDataBody = document.getElementById("test-data-body");
            this.tableDiv = document.getElementById("data-table-div");
            this.resultsDatabase = resultsDatabase;
            this.tableElement = document.getElementById("fit-test-data-table");
        }

        static getNextTabIndex() {
            const n = DataCollector.nextTabIndex;
            // advance by 2, so we can put the editor in the middle of adjacent cells and try to get shift-tab navigation to work properly
            // this doesn't seem to fix shift-tab tabindex traversal
            DataCollector.nextTabIndex += 2;
            return n;
        }

        appendToLog(message) {
            this.logTextArea.value += message;
            DataCollector.scrollToBottom(this.logTextArea);
        }

        appendToData(data) {
            this.dataTextArea.value += data;
            DataCollector.scrollToBottom(this.dataTextArea);
        }

        setInstructions(message) {
            this.instructionsTextArea.innerText = message;
            this.maybeSayItLater(message); // make sure instructions are queued.
        }

        setInstructionsForExercise(exerciseNum) {
            // TODO: don't hardcode this
            const exerciseInstructionsLookup = {
                1: "Normal breathing. Breathe normally.",
                2: "Heavy breathing. Take deep breaths.",
                3: "Jaw movement. Read a passage, sing a song, talk, or pretend to do so.",
                4: "Head movement. Look up, down, left, and right. Repeat."
            }
            this.setInstructions(`Perform exercise ${exerciseNum}: ${exerciseInstructionsLookup[exerciseNum]}`);
        }


        speechEnabled() {
            return document.getElementById("enable-speech-checkbox").checked;
        }

        speechVerbose() {
            return this.speechEnabled() && document.getElementById("enable-verbose-speech-checkbox").checked;
        }

        shouldSayParticleCount() {
            return this.speechEnabled() && document.getElementById("speak-concentration-checkbox").checked;
        }

        maybeSayIt(message) {
            if (this.speechEnabled()) {
                sayIt(message);
            }
        }

        maybeSayItLater(message) {
            if (this.speechEnabled()) {
                sayItLater(message);
            }
        }

        static scrollToBottom(theTextArea) {
            theTextArea.scrollTop = theTextArea.scrollHeight;
        }


        processLine(line) {
            // appendOutput(`processLine: ${line} (length: ${line.length})\n`);
            if (line.length === 0) {
                this.appendToLog("processLine() ignoring empty line\n");
                return;
            }
            // this.appendToLog(`${line}\n`);
            let match;

            match = line.match(NEW_TEST_PATTERN)
            if (match) {
                this.appendToData(`\nStarting a new test. ${new Date().toLocaleString()}\n`);
                this.setInstructionsForExercise(1);
                this.recordTestStart();
                return;
            }

            match = line.match(AMBIENT_READING_PATTERN);
            if (match) {
                let concentration = match.groups.concentration;
                this.appendToData(`ambient concentration: ${concentration}\n`);
                // this.currentTestData.samples.push({ambient: concentration});
                return;
            }

            match = line.match(MASK_READING_PATTERN);
            if (match) {
                let concentration = match.groups.concentration;
                this.appendToData(`mask concentration: ${concentration}\n`);
                this.setInstructions("Breathe normally");
                // this.currentTestData.samples.push({mask: concentration});
                return;
            }

            match = line.match(FIT_FACTOR_PATTERN);
            if (match) {
                const ff = match.groups.fitFactor;
                const exerciseNum = Number(match.groups.exerciseNumber);
                const result = match.groups.result;
                this.appendToData(`Exercise ${exerciseNum}: Fit factor is ${ff}. Result: ${result}\n`)
                this.setInstructionsForExercise(exerciseNum + 1);
                this.maybeSayItLater(`Score was ${ff}`)
                // this.beginExerciseTimoutId = this.scheduleBeginExercisePrompt(exerciseNum+1);
                // this.currentTestData.results.push({exercise_num: exerciseNum, fit_factor: ff, result: result});
                this.recordExerciseResult(exerciseNum, ff, result);
                return;
            }

            match = line.match(OVERALL_FIT_FACTOR_PATTERN);
            if (match) {
                const ff = match.groups["fitFactor"];
                const result = match.groups["result"];
                this.appendToData(`\nTest complete. ${result} with FF of ${ff}\n`);
                this.setInstructions(`Test complete. Score: ${ff}`);
                // this.currentTestData.results.push({exercise_num: "overall", fit_factor: ff, result: result});
                this.appendToLog(JSON.stringify(this.currentTestData) + "\n");
                this.recordTestComplete(ff, result);
                return;
            }

            if (line.match(TEST_TERMINATED_PATTERN)) {
                this.appendToData(`\nTest aborted\n`);
                this.setInstructions("Breathe normally");
                this.recordTestAborted();
                return;
            }

            match = line.match(COUNT_READING_PATTERN) || line.match(PARTICLE_COUNT_PATTERN);
            if (match) {
                if (!isSayingSomething()) {
                    const concentration = Number(match.groups.concentration);
                    if (this.shouldSayParticleCount()) {
                        const intConcentration = Math.ceil(concentration);
                        const conc = intConcentration < 20 ? (Math.ceil(concentration * 10) / 10).toFixed(1) : intConcentration;
                        const message = this.speechVerbose() ? `Particle count is ${conc}` : conc;
                        this.maybeSayIt(message);
                    }
                }
            }

        }

        recordTestComplete(ff, result) {
            if (!this.headerComplete) {
                this.addColumnToHeader("Final"); // alts: Overall, Net, Avg/Average, H-Mean / Mean
                this.headerComplete = true;
            }
            this.appendExerciseResult(ff, result);
        }

        recordTestAborted() {
            if (!this.testDataCurrentRow) {
                console.log("no current row, ignoring");
                return;
            }
            const cell = document.createElement("td");
            cell.setAttribute("colspan", "100%");
            cell.innerText = `aborted`;
            cell.classList.add("aborted");
            this.testDataCurrentRow.appendChild(cell);
            this.setInstructions("Test cancelled.");
            this.updateCurrentRowInDatabase();
        }

        /**
         * target must be a table cell (td)
         * Use a contentEditable DIV for auto-resizing editing box: https://stackoverflow.com/a/15866077
         * @param target
         * @return a Promise that completes when focus is lost
         */
        static beginEditing(target) {
            const input = document.createElement("div");
            input.setAttribute("contentEditable", "true");

            /** Swap out the tabindex with the input element so shift-tab works properly.
             * Otherwise, shift-tabbing will focus on the target (the td, which will re-enable editing mode).
             * Removing the tabindex on the td means shift-tab will focus on the cell to its left as intended.
             */
            input.setAttribute("tabindex", target.getAttribute("tabindex"));
            target.removeAttribute("tabindex");

            input.classList.add("editable-table-cell")
            input.innerHTML = target.innerHTML;
            target.replaceChildren(input);
            input.focus();

            return new Promise((resolve) => {
                input.onblur = (event) => {
                    target.setAttribute("tabindex", input.getAttribute("tabindex"));
                    // target.replaceChildren();
                    target.innerHTML = input.innerHTML;
                    resolve();
                }
            });
        }


        async recordTestStart(timestamp = new Date().toLocaleString()) {
            const table = this.tableElement;

            // TODO: use databinding
            function createTimestampCell() {
                const cell = document.createElement("td");
                cell.innerText = timestamp;
                return cell;
            }

            const resultsDb = this.resultsDatabase;
            function createEditableTableCell(parentRow) {
                const cell = document.createElement("td");
                cell.classList.add("editable");
                cell.setAttribute("tabindex", "" + DataCollector.getNextTabIndex());
                cell.onfocus = () => {
                    DataCollector.beginEditing(cell).then(() => {
                        const columns = getTableColumnNames(table);
                        const record = jsonifyTableRow(columns,parentRow);
                        resultsDb.updateTest(record);
                    });
                };
                return cell;
            }

            this.currentTestData = await this.resultsDatabase.createNewTest(); // primary key is the "ID" field
            this.currentTestData["Time"] = timestamp;
            // jsonifyTableRow(this.currentTestData);
            // updateTest()

            const row = this.testDataBody.insertRow(0);
            this.testDataCurrentRow = row;

            let testNumCell = document.createElement("td");
            testNumCell.innerText = this.currentTestData.ID;

            row.appendChild(testNumCell);
            row.appendChild(createTimestampCell(timestamp));

            row.appendChild(createEditableTableCell(row)); // participant
            row.appendChild(createEditableTableCell(row)); // mask
            row.appendChild(createEditableTableCell(row)); // notes

            // scroll to top (since we're inserting at the top
            this.tableDiv.scrollTop = 0;
        }

        recordExerciseResult(exerciseNum, ff, result) {
            if (this.exerciseCount < exerciseNum) {
                this.addColumnToHeader(`Ex ${exerciseNum}`);
                this.exerciseCount++;
            }
            this.appendExerciseResult(ff, result);
        }

        appendExerciseResult(ff, result) {
            if (!this.testDataCurrentRow) {
                console.log("no current row, ignoring");
                return;
            }
            const exerciseResultCell = document.createElement("td");
            exerciseResultCell.innerText = `${Math.floor(ff)}`;
            exerciseResultCell.classList.add(result.toLowerCase(), "results");  // todo: parse this out explicitly to pass/fail
            this.testDataCurrentRow.appendChild(exerciseResultCell);
            this.updateCurrentRowInDatabase();
        }

        updateCurrentRowInDatabase() {
            const columns = getTableColumnNames(this.tableElement);
            const record = jsonifyTableRow(columns, this.testDataCurrentRow);
            this.resultsDatabase.updateTest(record);
        }

        addColumnToHeader(heading) {
            const columnHeading = document.createElement("th");
            columnHeading.style.minWidth = "5vw";
            columnHeading.innerText = heading;
            this.testDataHeaderRow.appendChild(columnHeading);
        }

        /**
         * When we get results from the previous exercise, we can prompt the participant to start the next exercise.
         * If we've finished the last exercise of the test, we'll get the overall fit factor result soon. So we should
         * delay prompting for the next exercise in this case.
         * @param nextExerciseNum
         * @returns {number}
         */
        scheduleBeginExercisePrompt(nextExerciseNum) {
            const timeoutMs = 3200;
            const timeoutId = setTimeout(() => {
                this.beginExerciseTimoutId = null;
                this.setInstructionsForExercise(nextExerciseNum);
            }, timeoutMs);
            return timeoutId;
        }

        cancelBeginExercisePrompt() {
            if (this.beginExerciseTimoutId !== null) {
                this.appendToLog("cancelling begin exercise prompt\n");
                clearTimeout(this.beginExerciseTimoutId);
                this.beginExerciseTimoutId = null;
            }
        }
    }


    /*
     Text-to-speech functions
     */
    let selectedVoice;
    let speechRate = 1;
    let speechSynthesis;

    export function setupSpeechSynthesis() {
        const synth = window.speechSynthesis;
        const inputForm = document.querySelector("form");
        const inputTxt = document.getElementById("say-this");
        const voiceSelect = document.getElementById("voice-select");
        const speechSpeedElement = document.getElementById("speech-speed");
        const speechRateLabel = document.getElementById("speech-rate-label");
        let voices;

        function populateVoiceList() {
            voices = synth.getVoices();

            for (const voice of voices) {
                const option = document.createElement("option");
                option.textContent = `${voice.name} (${voice.lang})`;

                if (voice.default) {
                    option.textContent += " â€” DEFAULT";
                    option.selected = true;
                }

                option.setAttribute("data-lang", voice.lang);
                option.setAttribute("data-name", voice.name);
                voiceSelect.appendChild(option);
            }
            voiceSelect.onchange = event => selectedVoice = voices.find((voice) => voice.name === event.target.getAttribute("data-name"));

            speechSpeedElement.onchange = event => {
                speechRate = event.target.value;
                speechRateLabel.innerText = speechRate;
            }
            speechSpeedElement.value = speechRate; // init
            speechRateLabel.innerText = speechRate; // init
        }

        populateVoiceList();
        if (synth.onvoiceschanged !== undefined) {
            synth.onvoiceschanged = populateVoiceList;
        }


        inputForm.onsubmit = (event) => {
            event.preventDefault();

            sayIt(inputTxt.value);
            inputTxt.blur();
        };

        speechSynthesis = synth;
    }

    export function quickSetupSpeechSynthesis() {
        const synth = window.speechSynthesis;
        const defaultVoice = synth.getVoices().find((voice) => voice.default);

        if (synth.onvoiceschanged !== undefined) {
            // synth.onvoiceschanged = populateVoiceList;
        }

        speechSynthesis = synth;
        selectedVoice = defaultVoice;
        speechRate = 1;
    }

    export function isSayingSomething() {
        return speechSynthesis.speaking;
    }

    /**
     * enqueue
     * @param message
     */
    export function sayItLater(message) {
        console.log(`say it later: ${message}`)
        const utterThis = new SpeechSynthesisUtterance(message);
        utterThis.voice = selectedVoice;
        utterThis.rate = speechRate;

        speechSynthesis.speak(utterThis); // this enqueues
    }

    export function sayIt(message) {
        console.log(`say it ${message}`)
        const utterThis = new SpeechSynthesisUtterance(message);
        utterThis.voice = selectedVoice;
        utterThis.rate = speechRate;

        if(speechSynthesis.speaking) {
            speechSynthesis.cancel(); // stop current utterance
            // chrome needs a delay here for some reason, otherwise speak doesn't do anything.
            // 60 ms seems to be around the minimum delay
            setTimeout(() => speechSynthesis.speak(utterThis), 60)
        } else {
            speechSynthesis.speak(utterThis);
        }
    }

    /*
    Download data from an HTML elements in various formats.
    Not all combination of elements and formats are supported.
    */


    function getFilenamePrefix(htmlElement, filenamePrefixHint = "data") {
        return (htmlElement.id || htmlElement.nodeName || filenamePrefixHint) + "_";
    }

    /**
     * Download the terminal's contents to a file. from https://github.com/GoogleChromeLabs/serial-terminal/blob/main/src/index.ts
     */
    function createFauxLink(fileName, contents) {
        const linkContent = URL.createObjectURL(
            new Blob([new TextEncoder().encode(contents).buffer],
                {type: 'text/plain'}));
        const fauxLink = document.createElement('a');
        fauxLink.download = fileName;
        fauxLink.href = linkContent;
        return fauxLink;
    }

    /**
     * @param htmlElement must have a value property (for now)
     * @param filenameHint
     */
    export function downloadRawData(htmlElement, filenameHint = "data") {
        const fauxLink = createFauxLink(`${getFilenamePrefix(htmlElement, filenameHint)}${new Date().getTime()}.txt`, htmlElement.value);
        fauxLink.click();
    }

    export function downloadTableAsCSV(tableElement, filenameHint = "table") {
        const tableData = [];
        const rowElements = tableElement.getElementsByTagName("tr");
        for (let row = 0; row < rowElements.length; row++) {
            const rowData = [];
            let cells = rowElements[row].getElementsByTagName("td");
            if (cells.length === 0) {
                cells = rowElements[row].getElementsByTagName("th");
            }
            for (let i = 0; i < cells.length; i++) {
                rowData.push(cells[i].innerText);
            }
            tableData.push(rowData.map((value) => `"${value.replaceAll("\"", "\"\"")}"`).join(","));
        }

        const fauxLink = createFauxLink(`${getFilenamePrefix(tableElement, filenameHint)}${new Date().getTime()}.csv`, tableData.join("\n"));
        fauxLink.click();
    }

    export function jsonifyTableRow(orderedColumnNames, tableRowElement) {
        const orderedColumnCells = tableRowElement.getElementsByTagName("td");
        const rowData = {};
        for (let i = 0; i < orderedColumnNames.length; i++) {
            if (orderedColumnCells.length <= i) {
                break; // no more cells (aborted)
            }
            rowData[orderedColumnNames[i]] = orderedColumnCells[i].innerText; // todo: convert line breaks
        }
        return rowData;
    }

    export function getTableColumnNames(tableElement) {
        const columnHeadingElements = tableElement.getElementsByTagName("th");
        const columnNames = [];
        for (let i = 0; i < columnHeadingElements.length; i++) {
            columnNames.push(columnHeadingElements[i].innerText);
        }
        return columnNames;
    }

    export function downloadTableAsJSON(tableElement, filenameHint = "table") {
        const columnNames = getTableColumnNames(tableElement);

        const tableData = [];
        const rowElements = tableElement.getElementsByTagName("tr");
        for (let rowIndex = 0; rowIndex < rowElements.length; rowIndex++) {
            let tableRowElement = rowElements[rowIndex];
            const rowData = jsonifyTableRow(columnNames, tableRowElement);
            tableData.push(rowData);
        }

        const fauxLink = createFauxLink(`${getFilenamePrefix(tableElement, filenameHint)}${new Date().getTime()}.json`, JSON.stringify(tableData));
        fauxLink.click();
    }


    /*
    Wrapper around webusb-ftdi
     */
    // import {
    //     WebUSBSerialDevice
    // } from "https://cdn.jsdelivr.net/gh/emcee5601/webusb-ftdi@2f671812f65af4c78bf8b19d043a3a15a85cdfe9/webusb-ftdi.js";

    /**
     * make this sort of look like WebSerial.
     */
    export class FtdiSerial {
        async requestPort() {
            return new FtdiPortDataSource();
        }
    }

    export class FtdiPortDataSource {
        /**
         * When there is no data available, wait this amount of time before checking again.
         * @type {number}
         */
        noDataWaitTimeMs = 300;
        readable;
        writable;
        device;
        devicePort;
        inboundDataQueue = null;
        decoder = new TextDecoder();

        constructor() {
        }

        // must call this from a button
        async open(params) {
            this.device = new WebUSBSerialDevice({
                overridePortSettings: true, // TODO: not supported yet, always overrides baudrate
                // these are the defaults, this config is only used if above is true
                baudrate: params.baudRate,
                bits: 8, // TODO: override not supported yet
                stop: 1, // TODO: override not supported yet
                parity: false, // TODO: override not supported yet
                deviceFilters: [
                    // example filtered device; see code for more examples
                    {'vendorId': 0x0403, 'productId': 0x6001}, // 0403:6001 Future Technology Devices International, Ltd FT232 Serial (UART) IC
                ]
            });


            return new Promise((resolve, reject) => {
                this.device.requestNewPort().then((port) => {
                    this.devicePort = port;
                    this.readable = getReadableStreamFromDataSource(this); // this starts reading immediately  :(
                    this.writable = this.getWritableStreamFromDataSink(this);
                    resolve(port);
                }).catch((err) => {
                    console.log(`error requesting a port: ${err}`);
                    reject(err);
                });
            })
        }

        getWritableStreamFromDataSink(dataSink) {
            const queuingStrategy = new CountQueuingStrategy({ highWaterMark: 1 });
            const encoder = new TextEncoder();
            const decoder = new TextDecoder();
            return new WritableStream(
                {
                    // Implement the sink
                    write(chunk) {
                        const data = decoder.decode(chunk);
                        console.log(`sending to ftdi: ${data}`);
                        return new Promise((resolve, reject) => {
                            dataSink.devicePort.send(chunk).then((res) => {
                                console.log(`successfully sent to ftdi: ${res.status}, bytesWritten: ${res.bytesWritten}`);
                                resolve(res)
                            }).catch((err) => {
                                console.log(`error sending to ftdi: ${err.toString()}`);
                                reject(err)
                            });
                        });
                    },
                    close() {
                        console.log("ftdi sink closed")
                    },
                    abort(err) {
                        console.log("ftdi Sink error:", err);
                    },
                },
                queuingStrategy
            );
        }

        // called internally
        connectToPort() {
            // something wrong with the driver? in external control mode, we no longer get data callbacks here.

            this.inboundDataQueue = []; // this also flags that we're initialized
            try {
                // try to connect, connect receives two parameters: data callback and error callback
                this.devicePort.connect((chunk) => {
                    // this is data callback, print data to console
                    const decodedData = this.decoder.decode(chunk);
                    // logData(`${decodedData}`);
                    logSource(`data callback got ${chunk.length} bytes: ${decodedData}\n`)

                    // chunk is a Uint8Array so we can't just use + or +=
                    this.inboundDataQueue.push(chunk);
                }, (error) => {
                    // called if error receiving data
                    logSource("Error receiving data: " + error)
                });
                logSource('connected (probably)');
            } catch (e) {
                // called if can't get a port
                logSource("Error connecting to port: " + e.error)
                logSource(e)
            }
        }


        // Method returning promise when this push source is readable.
        async dataRequest() {
            const result = {
                bytesRead: 0,
                data: "",
            };

            if (this.inboundDataQueue === null) {
                this.connectToPort();
            }

            if (this.inboundDataQueue.length === 0) {
                // Data not available. We need a way to know if there is no more data or if we're just waiting.
                return new Promise((resolve) => {
                    setTimeout(() => {
                        console.log(`no data, waiting a bit...`);
                        this.dataRequest().then((res) => {
                            console.log(`trying to get more data...`);
                            resolve(res)
                        });  // is this the correct way to chain Promises?
                    }, this.noDataWaitTimeMs); // wait a little bit
                });
            }

            const chunks = this.inboundDataQueue.splice(0, this.inboundDataQueue.length); // is this thread safe?

            return new Promise((resolve) => {
                let bigChunkSize = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
                const bigChunk = new Uint8Array(bigChunkSize);

                // this has side effects...
                chunks.reduce((chunkIndex, chunk) => {
                    bigChunk.set(chunk, chunkIndex);
                    return (chunkIndex + chunk.length);
                }, 0);

                result.data = bigChunk;
                result.bytesRead = bigChunkSize;
                resolve(result);
            });
        }

        // Dummy close function
        close() {
            return;
        }
    }

    /*
      mock data source idea from https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams
     */

    const utf8Decoder = new TextDecoder("utf-8");

    /**
     * from https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultReader/read#example_2_-_handling_text_line_by_line
     * @param reader
     * @returns an iterator that returns data from the reader broken up into lines
     */

    export async function* getLines(reader) {
        async function readFromReader() {
            const result = await reader.read();
            if (!result.done && result.value) {
                // appendRaw(utf8Decoder.decode(result.value));
            }
            return result;
        }

        let {value: chunk, done: readerDone} = await readFromReader();
        chunk = chunk ? utf8Decoder.decode(chunk, {stream: true}) : "";


        let re = /\r\n|\n|\r/gm;
        let startIndex = 0;

        for (; ;) {
            let result = re.exec(chunk);
            if (!result) {
                if (readerDone) {
                    break;
                }
                let remainder = chunk.substring(startIndex);
                ({value: chunk, done: readerDone} = await readFromReader());
                chunk =
                    remainder + (chunk ? utf8Decoder.decode(chunk, {stream: true}) : "");
                startIndex = re.lastIndex = 0;
                continue;
            }
            yield chunk.substring(startIndex, result.index);
            startIndex = re.lastIndex;
        }
        if (startIndex < chunk.length) {
            // last line didn't end in a newline char
            yield chunk.substring(startIndex);
        }
    }



    export function getReadableStreamFromDataSource(pushSource) {
        return new ReadableStream({
            start(controller) {
                readRepeatedly().catch((e) => controller.error(e));

                function readRepeatedly() {
                    return pushSource.dataRequest().then((result) => {
                        if (result.data.length === 0) {
                            logSource(`No data from source: closing`);
                            controller.close();
                            return;
                        }

                        // logSource(`Enqueue data: ${result.data}`);
                        controller.enqueue(result.data);
                        return readRepeatedly();
                    });
                }
            },

            cancel() {
                logSource(`cancel() called on underlying source`);
                pushSource.close();
            },
        });
    }


    export class DataFilePushSource {
        static DEFAULT_DELAY_MS = 10;
        static encoder = new TextEncoder();
        reader = null;
        buffer = null;
        bufferIndex = 0;
        fileOrUrl;
        delayMs;

        constructor(fileOrUrl, delayMs= DataFilePushSource.DEFAULT_DELAY_MS) {
            this.fileOrUrl = fileOrUrl;
            this.delayMs = delayMs;
        }

        // Method returning promise when this push source is readable.
        async dataRequest() {
            const result = {
                bytesRead: 0,
                data: "",
            };

            if (this.buffer === null || this.bufferIndex >= this.buffer.length) {
                // need (more) data
                if (this.reader === null) {
                    this.reader = await fetch(this.fileOrUrl).then((result) => {
                        if (result.ok) {
                            return result.body.getReader();
                        } else {
                            throw new Error(`Failed to load protocol definitions. error: ${result.status}`);
                        }
                    })
                }

                const result = await this.reader.read();
                this.bufferIndex = 0;
                if (result.done) {
                    // no more data
                    this.buffer = []
                } else {
                    this.buffer = result.value;
                }
            }

            if (this.buffer.length === 0) {
                // no more data
                return new Promise((resolve) => resolve(result));
            }

            // some data not sent
            const end = this.bufferIndex + (this.bufferIndex + 3 < this.buffer.length ? 3 : this.buffer.length);
            const chunk = this.buffer.slice(this.bufferIndex, end);
            this.bufferIndex += chunk.length;
            return new Promise((resolve) => {
                // Emulate slow read of data
                setTimeout(() => {
                    result.data = chunk;
                    result.bytesRead = chunk.length;
                    resolve(result);
                }, this.delayMs);
            });
        }

        // Dummy close function
        close() {
            return;
        }
    }



    export function logSource(result) {
        console.log(`source: ${result}`);
    }

    export function logData(result) {
        // console.log(`data: ${result}`);
    }

    /*
    External control for the PortaCount 8020a
    The technical addendum describes the interface. Starts on page 13.
     https://tsi.com/getmedia/0d5db6cd-c54d-4644-8c31-40cc8c9d8a9f/PortaCount_Model_8020_Technical_Addendum_US?ext=.pdf
     */

    export class ExternalControl {
        static INVOKE_EXTERNAL_CONTROL = "J";
        static RELEASE_FROM_EXTERNAL_CONTROL = "G";
        static TEST_TO_SEE_N95_COMPANION_IS_ATTACHED = "Q";
        static SWITCH_VALVE_ON = "VN"; // ambient
        static SWITCH_VALVE_OFF = "VF"; // sample
        static DISABLE_CONTINUOUS_DATA_TRANSMISSION = "ZD";
        static ENABLE_CONTINUOUS_DATA_TRANSMISSION = "ZE";
        static REQUEST_RUNTIME_STATUS_OF_BATTERY_AND_SIGNAL_PULSE = "R";
        static REQUEST_SETTINGS = "S";
        static TURN_POWER_OFF = "Y";
        static SET_MASK_SAMPLE_TIME = "PTMxxvv";  // xx = exercise num [1..12], vv = time in seconds [10..99]
        static SET_AMBIENT_SAMPLE_TIME = "PTA00vv";  // vv = time in seconds [5..99]
        static SET_MASK_SAMPLE_PURGE_TIME = "PTPM0vv"; // vv = time in seconds [11..25]
        static SET_AMBIENT_SAMPLE_PURGE_TIME = "PTPA0vv"; // vv = time in seconds [4..25]
        static SET_FIT_FACTOR_PASS_LEVEL = "PPxxvvvvv"; // xx = memory location [1..12], vvvvv = pass level [0..64000]

        static DISPLAY_CONCENTRATION_ON_PORTACOUNT_PLUS = "Dxxxxxx.xx";
        static DISPLAY_FIT_FACTOR_PASS_LEVEL_ON_PORTACOUNT_PLUS = "Lxxxxxx";
        static DISPLAY_FIT_FACTOR_ON_PORTACOUNT_PLUS = "Fxxxxxx.x";
        static DISPLAY_OVERALL_FIT_FACTOR_ON_PORTACOUNT_PLUS = "Axxxxxx.x";
        static DISPLAY_EXERCISE_NUMBER_ON_PORTACOUNT_PLUS = "Ixxxxxxxx";
        static CLEAR_DISPLAY_ON_PORTACOUNT_PLUS = "K";
        static SOUND_BEEPER_INSIDE_THE_PORTACOUNT_PLUS = "Bxx";

        static encoder = new TextEncoder();
        static staticWriter; // todo: rewrite button setup so we don't need this static field

        constructor(writer) {
            this.writer = writer;
            ExternalControl.staticWriter = writer;
        }


        static setupButtons(containerElement) {
            const controlModeButton = this.makeButton("control-type-button", "Internal Control");
            controlModeButton.style.backgroundColor = "yellow";
            controlModeButton.onclick = (event) => {
                if(controlModeButton.value === "Internal Control") {
                    controlModeButton.value = "External Control";
                    controlModeButton.style.backgroundColor = "green";
                    this.assumeManualControl();
                } else {
                    controlModeButton.value = "Internal Control";
                    controlModeButton.style.backgroundColor = "yellow";
                    this.releaseManualControl();
                }
            }
            containerElement.appendChild(controlModeButton);

            const valvePositionButton = this.makeButton("valve-position-button", "Sampling from Mask");
            valvePositionButton.style.backgroundColor = "yellow";
            valvePositionButton.onclick = (event) => {
                if(valvePositionButton.value === "Sampling from Ambient") {
                    valvePositionButton.value = "Sampling from Mask";
                    valvePositionButton.style.backgroundColor = "green";
                    this.sampleMask()
                } else {
                    valvePositionButton.value = "Sampling from Ambient";
                    valvePositionButton.style.backgroundColor = "yellow";
                    this.sampleAmbient();
                }
            }
            containerElement.appendChild(valvePositionButton);

            const dataTransmitModeButton = this.makeButton("data-transmit-mode-button", "Transmitting");
            dataTransmitModeButton.style.backgroundColor = "green";
            dataTransmitModeButton.onclick = (event) => {
                if(dataTransmitModeButton.value === "Paused") {
                    dataTransmitModeButton.value = "Transmitting";
                    dataTransmitModeButton.style.backgroundColor = "green";
                    this.enableDataTransmission();
                } else {
                    dataTransmitModeButton.value = "Paused";
                    dataTransmitModeButton.style.backgroundColor = "yellow";
                    this.disableDataTransmission();
                }
            }
            containerElement.appendChild(dataTransmitModeButton);

            const requestSettingsButton = this.makeButton("request-settings-button", "Request Settings");
            requestSettingsButton.onclick = (event) => {
                this.requestSettings();
            }
            containerElement.appendChild(requestSettingsButton);

            const beepButton = this.makeButton("beep-button", "Beep!");
            beepButton.onclick = (event) => {
                this.beep();
            }
            containerElement.appendChild(beepButton);

            const powerOffButton = this.makeButton("power-off-button", "Power Off");
            powerOffButton.onclick = (event) => {
                this.powerOff();
            }
            containerElement.appendChild(powerOffButton);
        }

        static makeButton(id, name) {
            const controlModeButton = document.createElement("input");
            controlModeButton.setAttribute("type", "button");
            controlModeButton.setAttribute("value", name);
            controlModeButton.id = id;
            return controlModeButton;
        }

        static assumeManualControl() {
            this.sendCommand(ExternalControl.INVOKE_EXTERNAL_CONTROL);
        }

        static releaseManualControl() {
            this.sendCommand(ExternalControl.RELEASE_FROM_EXTERNAL_CONTROL);
        }

        static enableDataTransmission() {
            this.sendCommand(ExternalControl.ENABLE_CONTINUOUS_DATA_TRANSMISSION);
        }

        static disableDataTransmission() {
            this.sendCommand(ExternalControl.DISABLE_CONTINUOUS_DATA_TRANSMISSION);
        }

        static sampleAmbient() {
            this.sendCommand(ExternalControl.SWITCH_VALVE_ON);
        }

        static sampleMask() {
            this.sendCommand(ExternalControl.SWITCH_VALVE_OFF);
        }

        static requestSettings() {
            this.sendCommand(ExternalControl.REQUEST_SETTINGS);
        }

        static powerOff() {
            this.sendCommand(ExternalControl.TURN_POWER_OFF);
        }

        static beep(tenthsOfSeconds = 2) {
            this.sendCommand(`B${String(tenthsOfSeconds).padStart(2, "0")}`);
        }

        static sendCommand(command) {
            let terminalCommand = `${command}\r`;
            let chunk = this.encoder.encode(terminalCommand);
            this.staticWriter.write(chunk);
        }
    }

    /*
    Stores raw data lines from the data collector. Suitable for parsing with the updated simulator.
     */

    export class SimpleDB {
        static DEFAULT_DB_NAME = "raw-serial-line-data-db";
        static SERIAL_LINE_OBJECT_STORE = "serial-line-data";
        db;
        dbName;
        constructor(name = SimpleDB.DEFAULT_DB_NAME) {
            this.dbName = name;
            const request = window.indexedDB.open(this.dbName, 1);
            // use arrow here so `this` inside the callback points to the SimpleDB instance.
            request.onsuccess = (event) => this.onOpenSuccess(event);
            request.onerror = (event) => this.onOpenError(event);
            request.onupgradeneeded = (event) => this.onUpgradeNeeded(event);
        }

        onOpenSuccess(event) {
            let database = event.target.result;
            console.log("Database Opened", database, event);
            this.db = database;
        }

        onOpenError(event) {
            console.error(`Database error: ${event.target.error?.message}`);
        }

        onUpgradeNeeded(event) {
            // Save the IDBDatabase interface
            const theDb = event.target.result;

            console.warn(`Database upgrade needed: ${theDb.name}`);
            // Create an objectStore for this database
            const objectStore = theDb.createObjectStore(SimpleDB.SERIAL_LINE_OBJECT_STORE, {autoIncrement: true, keyPath: "index"});
        }


        // TODO: wrap these into an object
        static ONE_HOUR = 60 * 60 * 1000;
        keepRecords = [];
        now = new Date(); // use .getTime() to get epoch time
        timeCutoff = this.getUpdatedTimeCutoff(this.now.getTime());

        /**
         * Return a recent contiguous block of lines. Look at the timestamp of the record. Stop when there is a gap of more than 1 hour between timestamps.
         * Don't return anything if the most recent record is more than 1 hour old.
         * @param callback
         */
        getSomeRecentLines(callback) {
            const transaction = this.openTransaction("readonly");
            const request = transaction.objectStore(SimpleDB.SERIAL_LINE_OBJECT_STORE).openCursor(null, "prev");
            let done = false;

            request.onerror = (event) => {
                console.log(`getSomeRecentLines openCursor request error ${event}`);
            }
            request.onsuccess = (event) => {
                console.log(`getSomeRecentLines openCursor request complete: ${event}`);
                const cursor = event.target.result;
                if (cursor) {
                    // cursor.key contains the key of the current record being iterated through
                    // note that there is no cursor.value, unlike for openCursor
                    // this is where you'd do something with the result
                    console.log(`got key ${cursor.key}`);

                    const recordTimestamp = Date.parse(cursor.value.timestamp);
                    if( recordTimestamp > this.timeCutoff) {
                        // keep
                        this.keepRecords.push(cursor.value);
                        this.timeCutoff = this.getUpdatedTimeCutoff(recordTimestamp);
                        cursor.continue();
                    } else {
                        // done
                        // how to abort / close the cursor?
                        console.log(`stopping after ${this.keepRecords.length} records. other records are too old.`);
                        done = true;
                    }

                    // callback();
                } else {
                    // no more results
                    console.log("cursor done");
                    done = true;
                }

                if(done) {
                    // now we can call the callback with records we're keeping in order of oldest to newest
                    console.log(`collected ${this.keepRecords.length} records`);
                    while (this.keepRecords.length > 0) {
                        callback(this.keepRecords.pop());
                    }
                }
            }
        }

        getUpdatedTimeCutoff(recordTimestamp) {
            // return recordTimestamp - SimpleDB.ONE_HOUR;
            return recordTimestamp - 150* 60*1000; // some minute for debugging
        }

        /**
         * Return the json representation of the data that was inserted. Includes the generated primary key.
         * @param record
         */
        addLine(line) {
            if(!this.db) {
                console.log("database not ready");
                return {};
            }
            const transaction = this.openTransaction("readwrite");

            const record = {
                timestamp: new Date().toISOString(),
                data: line,
            };
            const request = transaction.objectStore(SimpleDB.SERIAL_LINE_OBJECT_STORE).add(record);
            request.onerror = (event) => {
                console.log(`addRecord request error ${event}`);
            }
            request.onsuccess = (event) => {
                console.log(`addRecord request complete: ${event}, new key is ${request.result}`);
            }
        }

        openTransaction(mode) {
            const transaction = this.db.transaction([SimpleDB.SERIAL_LINE_OBJECT_STORE], mode);
            transaction.oncomplete = (event) => {
                console.log(`transaction complete: ${event}`);
            }
            transaction.onerror = (event) => {
                console.log(`transaction error ${event}`);
            }
            return transaction;
        }
    }

    /*
    Stores data from results table.
     */

    export class SimpleResultsDB {
        static DEFAULT_DB_NAME = "fit-test-data-db";
        static TEST_RESULTS_OBJECT_STORE = "test-results-table-data";
        db;
        dbName;
        constructor(name = SimpleResultsDB.DEFAULT_DB_NAME) {
            this.dbName = name;
            const request = window.indexedDB.open(this.dbName, 2);
            // use arrow here so `this` inside the callback points to the SimpleResultsDB instance.
            request.onsuccess = (event) => this.onOpenSuccess(event);
            request.onerror = (event) => this.onOpenError(event);
            request.onupgradeneeded = (event) => this.onUpgradeNeeded(event);
        }

        onOpenSuccess(event) {
            let database = event.target.result;
            console.log("Database Opened", database, event);
            this.db = database;
        }

        onOpenError(event) {
            console.error(`Database error: ${event.target.error?.message}`);
        }

        onUpgradeNeeded(event) {
            // Save the IDBDatabase interface
            const theDb = event.target.result;

            console.warn(`Database upgrade needed: ${theDb.name}`);
            // Create an objectStore for this database
            const objectStore = theDb.createObjectStore(SimpleResultsDB.TEST_RESULTS_OBJECT_STORE, {autoIncrement: true, keyPath: "ID"});
        }


        // TODO: wrap these into an object
        static ONE_HOUR = 60 * 60 * 1000;
        keepRecords = [];
        now = new Date(); // use .getTime() to get epoch time
        timeCutoff = this.getUpdatedTimeCutoff(this.now.getTime());

        /**
         * Return a recent contiguous block of data. Look at the timestamp of the record. Stop when there is a gap of more than 1 hour between timestamps.
         * Don't return anything if the most recent record is more than 1 hour old.
         * @param callback
         */
        getSomeRecentData(callback) {
            const transaction = this.openTransaction("readonly");
            const request = transaction.objectStore(SimpleResultsDB.TEST_RESULTS_OBJECT_STORE).openCursor(null, "prev");
            let done = false;

            request.onerror = (event) => {
                console.log(`getSomeRecentData openCursor request error ${event}`);
            }
            request.onsuccess = (event) => {
                console.log(`getSomeRecentData openCursor request complete: ${event}`);
                const cursor = event.target.result;
                if (cursor) {
                    console.log(`got key ${cursor.key}`);

                    const recordTimestamp = Date.parse(cursor.value.Time);
                    if( recordTimestamp > this.timeCutoff) {
                        // keep
                        this.keepRecords.push(cursor.value);
                        this.timeCutoff = this.getUpdatedTimeCutoff(recordTimestamp);
                        cursor.continue();
                    } else {
                        // done
                        // how to abort / close the cursor?
                        console.log(`stopping after ${this.keepRecords.length} records. other records are too old.`);
                        done = true;
                    }

                    // callback();
                } else {
                    // no more results
                    console.log("cursor done");
                    done = true;
                }

                if(done) {
                    // now we can call the callback with records we're keeping in order of oldest to newest
                    console.log(`collected ${this.keepRecords.length} records`);
                    while (this.keepRecords.length > 0) {
                        callback(this.keepRecords.pop());
                    }
                }
            }
        }

        getUpdatedTimeCutoff(recordTimestamp) {
            return recordTimestamp - SimpleResultsDB.ONE_HOUR *999; // debugging multiply hours by some large number
        }

        /**
         * Return the json representation of the data that was inserted. Includes the generated primary key.
         * @param record
         */
        async createNewTest() {
            if(!this.db) {
                console.log("database not ready");
                return new Promise((resolve, reject) => reject("database not ready"));
            }
            const transaction = this.openTransaction("readwrite");

            const record = {
                // empty for now
            };
            const request = transaction.objectStore(SimpleResultsDB.TEST_RESULTS_OBJECT_STORE).add(record);
            return new Promise((resolve, reject) => {
                request.onerror = (event) => {
                    let errorMessage = `createNewTest request error ${event}`;
                    console.log(errorMessage);
                    reject(errorMessage);
                }
                request.onsuccess = (event) => {
                    console.log(`createNewTest request complete: ${event}, new key is ${request.result}`);
                    // TODO: fetch the whole record and return that instead of constructing this by hand?
                    resolve({ID: request.result});
                }
            });
        }

        async updateTest(record) {
            if(!this.db) {
                console.log("database not ready");
                return new Promise((resolve, reject) => reject("database not ready"));
            }

            // make sure ID is numeric?
            record.ID = Number(record.ID);
            const transaction = this.openTransaction("readwrite");

            const request = transaction.objectStore(SimpleResultsDB.TEST_RESULTS_OBJECT_STORE).put(record);
            return new Promise((resolve, reject) => {
                request.onerror = (event) => {
                    let errorMessage = `updateTest request error ${event}`;
                    console.log(errorMessage);
                    reject(errorMessage);
                }
                request.onsuccess = (event) => {
                    console.log(`updateTest request complete: ${event}, key is ${request.result}`);
                    resolve({ID: request.result}); // todo: return something more appropriate for an update
                }
            });
        }

        openTransaction(mode) {
            const transaction = this.db.transaction([SimpleResultsDB.TEST_RESULTS_OBJECT_STORE], mode);
            transaction.oncomplete = (event) => {
                console.log(`transaction complete: ${event}`);
            }
            transaction.onerror = (event) => {
                console.log(`transaction error ${event}`);
            }
            return transaction;
        }
    }

    class App {
        baudRateSelector = document.getElementById("baud-rate-selector")
        logTextArea = document.getElementById("log-text-area")
        rawDataTextArea = document.getElementById("raw-data")
        dataTextArea = document.getElementById("interpreted-data")
        instructionsTextArea = document.getElementById("instructions");


        connectedPort;
        reader;
        readableStreamClosed;
        writer;
        writableStreamClosed;
        simpleDb;
        simpleResultsDb;
        dataCollector;

        logit(message) {
            console.log(message);
            this.dataCollector.appendToLog(message);
        }


        serialProbe() {
            console.log("serialProbe...");
            if ("serial" in navigator) {
                this.logit("serial supported!")
            } else {
                this.logit("no serial support :(")
            }
            let promise = navigator.serial.getPorts().then((ports) => {
                let message = `got serial ports: ${ports.toString()}`;
                this.logit(message)
            })
        }

        serialRequest() {
            const baudRate = this.baudRateSelector.value;

            if ("serial" in navigator) {
                this.logit("serial supported!")
            } else {
                this.logit("no serial support. As of this writing, web serial is only supported on desktop chrome.")
            }

            let promise = navigator.serial.requestPort().then((port) => {
                this.logit(`got serial port ${port.toLocaleString()}, using baud rate ${baudRate}`)
                port.open({baudRate: baudRate}).then((event) => {
                    this.logit(`opened ${event}`)
                    this.monitor(port.readable.getReader());
                    this.control(port.writable.getWriter());
                })
            })
        }

        ftdiRequest() {
            const baudRate = this.baudRateSelector.value;
            const serial = new FtdiSerial();
            serial.requestPort().then((port) => {
                port.open({baudRate: baudRate}).then((event) => {
                    this.logit(`ftdi opened ${event}`)
                    this.monitor(port.readable.getReader());
                    this.control(port.writable.getWriter());
                })
            })
        }

        autodetectBaudRate() {
            // according to the 8020 technical manual, everything is N81
            // factory setting is 1200
            // supported values are 300, 600, 1200, 2400, 9600

        }

        loadFromSerialDataDatabase() {
            const dataCollector = this.dataCollector; // preserve the correct this pointer because this method is called from a callback
            const f = function (record) {
                console.log(`loading from db: ${record.data}\n`);
                dataCollector.processLine(record.data);
            };
            this.simpleDb.getSomeRecentLines(f);
        }

        loadFromResultsDatabase() {
            const f = function (record) {
                console.log(`loading from db: ${JSON.stringify(record)}\n`);
            };
            this.simpleResultsDb.getSomeRecentData(f);
        }


        // use simulator as data source
        simulatorRequest() {
            const fakeReader = getReadableStreamFromDataSource(new DataFilePushSource("/src/test-data.txt", 0)).getReader();
            this.monitor(fakeReader);
        }

        setupButtons() {
            const connectButton = document.getElementById("connect-button");
            connectButton.onclick = (event) => {
                const selectedDataSource = document.getElementById("data-source-selector").value
                switch (selectedDataSource) {
                    case "ftdi":
                        this.ftdiRequest();
                        break;
                    case "web-serial":
                        this.serialRequest();
                        break;
                    case "simulator":
                        this.simulatorRequest();
                        break;
                    case "database":
                        this.loadFromSerialDataDatabase();
                        break;
                    case "results-db":
                        this.loadFromResultsDatabase();
                        break;
                    default:
                        this.logit(`Unsupported data source: ${selectedDataSource}`);
                }
            }

            const downloadButton = document.getElementById("download-button");
            downloadButton.onclick = (event) => {
                const table = document.getElementById("fit-test-data-table");
                const selector = document.getElementById("download-file-format-selector");
                switch (selector.value) {
                    case "raw":
                        downloadRawData(this.rawDataTextArea);
                        break;
                    case "csv":
                        downloadTableAsCSV(table);
                        break;
                    case "json":
                        downloadTableAsJSON(table);
                        break;
                    default:
                        console.log(`unsupported download file format: ${selector.value}`);
                }
            }

            // const stop_monitor_button = document.getElementById("stop-monitor-button");
            // stop_monitor_button.onclick = (event) => {
            //     stopMonitor();
            // }
        }


        appendRaw(message) {
            this.rawDataTextArea.value += message;
            DataCollector.scrollToBottom(this.rawDataTextArea);
        }

        async control(writer) {
            const remoteControl = new ExternalControl(writer);
        }

        async monitor(reader) {
            for await (let line of getLines(reader)) {
                const timestamp = new Date().toISOString();
                if (line.trim().length > 0) {
                    // we only care about non-empty lines
                    this.appendRaw(`${timestamp} ${line}\n`); // not really raw anymore since we've re-chunked into lines.
                    this.simpleDb.addLine(line);
                }
                this.dataCollector.processLine(line);
            }
            console.log("monitor reached end of reader");
        }


        onConnect = function (event) {
            console.log(`connected ${event}`)
            this.connectedPort = event.target;
            this.monitor(this.connectedPort);
        };


        setupMonitor() {
            if("serial" in navigator) {
                navigator.serial.addEventListener('connect', this.onConnect)
            } else {
                console.log("navigator.serial not present")
            }
        }


        async stopMonitor() {
            this.logit("stopping monitor")
            const textEncoder = new TextEncoderStream();
            this.writer = textEncoder.writable.getWriter();
            this.writableStreamClosed = textEncoder.readable.pipeTo(this.connectedPort.writable);

            this.reader.cancel();
            await this.readableStreamClosed.catch(() => { /* Ignore */
            });

            await this.writer.close();
            await this.writableStreamClosed;

            await this.connectedPort.close();
        }

        maybeAutoConnect() {
            let promise = navigator.serial.getPorts().then((ports) => {
                let message = `got serial ports: ${ports.toString()}`;
                if (ports.length === 1) {
                    this.logit("found 1 serial port, attempting to auto-connect...")
                    const baudRate = this.baudRateSelector.value;
                    const port = ports[0];
                    port.open({baudRate: baudRate}).then((event) => {
                        this.logit(`opened ${event}`)
                        this.monitor(port.readable.getReader());
                    })
                }
            })

        }

        setupDB() {
            this.simpleDb = new SimpleDB();
            this.simpleResultsDb = new SimpleResultsDB()
            this.dataCollector = new DataCollector(this.logTextArea, this.dataTextArea, this.instructionsTextArea, this.simpleResultsDb);
        }
    }


    quickSetupSpeechSynthesis();

    const app = new App();
    app.setupDB();
    app.setupButtons();
    app.setupMonitor();
    ExternalControl.setupButtons(document.getElementById("portacount-controls-fieldset"));

    // maybeAutoConnect();
    // protect against un/reload most of the time
    window.addEventListener("beforeunload", (event) => {
        event.preventDefault();
    });

</script>
</body>
</html>
